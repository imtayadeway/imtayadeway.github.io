---
layout: post
title: Testing Rails in 2020
tags:
- testing
- ruby
date: 2020-11-06 19:11:17
---

Like countless others, I learned Ruby on Rails (and a great deal more) from Michael Hartl's [Ruby on Rails Tutorial][]. Though I haven't kept up with the most recent revisions, I know that back in 2012 things were a bit different. In particular, I learned that it was the done thing to eschew the testing framework that came with Rails in favor of RSpec, to toss aside the fixtures library in favor of something called Factory Girl (since renamed Factory Bot), along with a wealth of other tools and libraries, too numerous to mention here. Now I believe Hartl has abandoned much of that in favor (ETOOMANYFAVORS) of using only the things that come with Rails by default. I'm not that surprised - I recall this being a lot to learn all at once, and it felt awkward to be fighting the framework I was trying to learn, whose very ethos is following the conventions that Rails prescribes, before I could even grasp the nuances of why I might be doing this.

As influential as Hartl's tutorial may have been, this change in the tide it seems has failed to make much of a splash in the Ruby community at large. At work, in 2020, Heroku has all but standardized on using Rails/RSpec/Factory Bot for all its Ruby components. In this post I want to expose some of the assumptions underpinning these choices. I'll also suggest that the Rails defaults are not merely a better choice for beginners, but may be better all round.

I don't want to dwell too much on the choice of RSpec. I think it is a fine testing framework, I've contributed to it, and I especially love its extensive expectations library, which I've also written about before. I also love Minitest. Though I've used it less, I am now using Minitest for all my new personal projects. I won't say that one is better than the other. Sam Pippen described RSpec as a "tool for legacy code bases" (actual quote needed) and this bears out in my experience - I'd probably prefer to use RSpec to retrofit a test suite to a legacy code base, but prefer to use Minitest for greenfield development.

Factory Bot, on the other hand, I think bears some extra scrutiny. thoughtbot sold Factory Bot entirely on the basis of addressing the Mystery Guest problem, a well-known XUnit Test Antipattern (citation needed). It trades on allowing you to write clearer tests at the expense of having to create and rollback every test fixture you need for every test, starting every test with a pristine, blank database. It would be pertinent to point out that test slowness has been a common complaint for as long as I have been using Rails, and that many attempts have tried (and failed) to address this. You would think then that the Mystery Guest problem had better be a significant one for this to be a good trade off.

For anyone unfamiliar, the Mystery Guest problem is as follows:

> The test reader is not able to see the cause and effect between fixture and verification logic because part of it is done outside the Test Method. [^1]

In a vanilla Rails application, this problem is emplified in the use of Rails' persistent fixtures:

```ruby
RSpec.describe User do
  it "has a full name" do
    expect(users(:alice).full_name).to eq("Alice Aaronson") # please change this
  end
end
```

To the test reader, it's not clear where the user's full name comes from, or from what data it is derived. To contrast, with Factory Bot:

```ruby
RSpec.describe User do
  it "has a full name" do
    user = create(:user, first: "Alice", last: "Aaronson")

    expect(user.fullname).to eq("Alice Aaronson")
  end
end
```

In this example it is immediately clear to the reader the relationship between the data that was passed to the fixture and the derived outcome of the full name text.

Since the Mystery Guest is an XUnit antipattern, it is fitting that Factory Bot allows us to follow good XUnit patterns, namely the four-phase test pattern (though only the setup and verification steps are required in this example) to write tests that tell a story about the code being exercised in the system. It is only natural then that thoughtbot feel strongly that you should also follow XUnit testing patterns when you write your specs. (citation needed)

The big problem here is that RSpec is not an XUnit style test framework, and it is my observation that most people do not follow XUnit best practices, preferring to write highly idiomatic RSpec code instead:

```ruby
RSpec.describe User do
  let(:user) { create(:user, first: "Alice", last: "Aaronson") }

  # 100s of lines of test code

  it "has a fullname" do
    expect(user.fullname).to eq("Alice Aaronson")
  end
end
```

Or, alternatively:

```ruby
RSpec.describe User
  let(:first) { "Alice" }
  let(:last) { "Aaronson" }
  subject(:user) { create(:user, first: first, last: last) }

  # 100s of lines of test code

  describe "#fullname" do
    let(:first) { "Bob" }
    let(:last) { "Baker" }

    its(:fullname) { should eq("Bob Baker") }
  end
end
```

As you can see, we have now thwarted our attempt at addressing the Mystery Guest problem simply by writing idiomatic RSpec code. RSpec is not an XUnit test framework and it is not its goal to exemplify all of the XUnit test patterns.

If the authors of Factory Bot assumed that we were going to discard parts of RSpec (see Let's Not) in the pursuit of more readable, XUnit-style tests, it is surprising that they did not recommend we use, you know, an actual XUnit test framework, such as Minitest:

```ruby
class TestUser < Minitest::Test
  def test_full_name
    # setup
    user = create(:user, first: "Alice", last: "Aaronson")

    # verification
    assert_equal("Alice Aaronson", user.full_name)
  end
end
```

The other problem that I've found with Factory Bot is that some of its own features undercut its original aim by helping us to write Obscure Tests. Using traits, for example:

```ruby
# spec/factories.rb
FactoryBot.factory(:user) do
  first { "Alice" }
  last { "Aaronson" }

  trait :adult do
    date_of_birth { 21.years.ago }
  end
end

# spec/models/user_spec.rb
RSpec.describe do
  example "adulthood" do
    user = create(:user, :adult)
    expect(user).to be_adult
  end
end
```

Sure, I can see the fixture there in the test body, but now it's unclear to me what conditions were necessary to create in order to drive that outcome. Compare this to Rails fixtures:

```yaml
# spec/fixtures/users.yml

alice:
  first: Alice
  last: Aaronson
  date_of_birth: <%= 21.years.ago %>
```

```ruby
# spec/models/user_spec.rb

RSpec.describe User do
  describe "adulthood" do
    specify "over 21" do
      expect(users(:alice)).to be_adult
    end
  end
end
```

With Factory Bot, we have to internalize what data makes up the traits we've defined. With Rails' fixtures we have to internalize the story of Alice as a person, and all the characteristics she embodies. But it is essentially the same problem.

If we find our test suites rife with obscure tests and we are using Factory Bot, then we have gained nothing and only made our tests slower with all the extra overhead. I recommend then, if you care about test readability and maintainability, that if you want to use Factory Bot, only to use its most basic features, and to use it with an XUnit-style framework such as Minitest. And if you are not tied to using Factory Bot, or wish you had faster tests, consider using Rails' fixtures instead. And honestly, why not Minitest *and* Rails' fixtures? For greenfield development, this is precisely the setup that Rails provides you with right from the moment you type `rails new`. It'll make both learning Rails and onboarding people onto your project more accessible by reducing the number of things you have to learn. And it's much simpler to be able to say you follow all of the conventions that Rails sets as you point its documentation, than to explain that you follow some of the conventions, but have some big disagreements with Rails when it comes to testing. You'll have faster (but still slowish) tests, with less setup, because you won't have to recreate the world for every test that you execute.

My experience right from starting with the Ruby on Rails Tutorial, through everything I've worked on professionally, has been that every project has had some variation of this complicated setup I learned back in 2012. If this is your experience too, I invite you to experiment in your next Rails project with the default test framework. Keep an open mind, play around with it, notice the differences, allow yourself to feel any of the pain points that come up, and perhaps any pleasant surprises, before evaluating. If you find yourself still preferring your bespoke setup, you may walk away with a richer understanding of the problems those tools were trying to address, and maybe you'll write better tests. Or, like me, you may decide that whatever wisdom we had back in 2012 (or whenever it is that we established this cultural departure from the default Rails test framework) doesn't suit us as well in 2020.

[Ruby on Rails Tutorial]: https://www.railstutorial.org/
[Mystery Guest]: http://xunitpatterns.com/Obscure%20Test.html#Mystery%20Guest
