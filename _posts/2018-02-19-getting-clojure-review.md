---
layout: post
title: Getting Clojure
tags:
- review
- books
date: 2018-02-19 10:14:24
---

When I started my first job I was programming in Ruby *sans* Rails,
and knew I had to get up to speed quickly. I purchased Russ Olsen's
*Eloquent Ruby* (2011) and read it cover to cover, though I struggled
a bit towards the end. I tried some things out, and then I read it
again. Then I played around some more. I learned the joys of
metaprogramming and then burnt my fingers. I went back and read it a
third time, now with the understanding that some of the things in the
back were dangerous.

Up until *Eloquent Ruby*, the resources I had used to learn all had
the same agenda: how to tell the computer to do stuff. In other words,
they would describe the *features* of things without spending too much
time on the *attitudes* toward them. And it is much harder to do the
latter.

The concept of *Eloquent Ruby* came as a revelation to me at the
time - the idea that there were not just rules that make up a
language, but idioms too, attitudes that might even change over
time. I loved the idea that I could learn to speak Ruby not just
adequately but like a native.

By this time I felt bold enough to call myself a Rubyist, and I owed
much of the enthusiasm I felt toward the language, and the success I
had early on in my career, to this book. I bought another of Olsen's
books on design patterns and read it cover to cover, again, multiple
times. I was ambitious and knew that "good" programmers had experience
and expertise working in different programming paradigms while still
not sure in what direction I would go. So I learned with great
interest that he was either working on, or had at least declared an
intention to write, a book about Clojure.

I had no idea at this point what Clojure or even Lisp was, but the
author had gained my trust enough for me to want to read about his new
book, whatever it was about.

And of course I had no clue at the time that this book would be in the
pipeline for years. I understand; these things take time. But, being
impatient, when I felt confident enough to start learning another
language, I decided to go ahead with Clojure anyway.

I have now played with it for about 3 years, have pored through some
books that were good at what they set out to do (exhaustively survey
the features of the language), have built some things of a certain
size. Alas, not getting to code and think in my second language every
day, I have never felt that I really "got" Clojure, that I really knew
it in the same way that I knew Ruby. I could not properly call myself
a Clojurist (do they even call themselves that? See, I don't know).

So I was pretty psyched when I learned that Olsen's book was nearing
completion, and that its title was, perfectly, *Getting Clojure*. When
it came out in beta form, I did something I almost never do - I bought
the eBook (I typically like to do my reading away from the computer).

And it has not disappointed. I am so happy that all the elements of
Olsen's style are present and on top form - his gentle humor, his
writing with compassion for the learner. He knows crucially what to
leave out and what to explain deeper, to illustrate. There are
examples, contrived, yet so much more compelling than most (it's hard
to formulate new examples that are sufficiently complex yet small and
interesting enough to sustain interest). There are lots of details on
*why* you might want to use a particular thing, or more importantly,
why you might not want to - in Olsen's words "staying out of
trouble" - details that are so vital to writing good, idiomatic code
in whatever language. And there are examples of real Clojure in use,
often pulled from the Clojure source itself, that not only illustrate
but give me the confidence to dive in myself, something that wouldn't
have occurred to me alone.

It seems ironic that *Getting Clojure* isn't the book I wanted way
back when I first heard about it, but it is the book that I need now.
I enjoyed going over the earlier chapters, cementing knowledge along
the way, forming new narratives that simplify the surface area of the
language while giving me the things I need to know to find out
more. And it gave me the confidence to dive way deeper than I thought
would be comfortable. For example, Olsen encourages you to write your
own Lisp implementation as an aside while he looks at the core of
Clojure's. I went ahead and did this and am so glad that I did - I
feel like I have gained a much deeper understanding of computer
programs in general, something that may have been lacking in my not
coming from a Computer Science background.

I have no doubt that this book will appeal to many others from
different backgrounds, different places in their development. But I
can confidently say that if, like myself, you are self taught, or
don't come from a "traditional" background, perhaps Ruby or a similar
dynamic language is your bread and butter but you are trying to expand
your horizons, if you need materials that focus on the learner and
building up understanding in a more structured way, *Getting Clojure*
gets my highest possible recommendation.
